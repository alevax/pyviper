<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyviper package &mdash; pyviper 1.0.6 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=e2a723ec"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Tutorial 1 - Analyzing scRNA-seq data at the Protein Activity Level" href="Tutorial-1.html" />
    <link rel="prev" title="pyVIPER (VIPER Analysis in Python for single-cell RNASeq)" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pyviper
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">pyviper package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pyviper-area">pyviper.aREA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pyviper-narnea">pyviper.NaRnEA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyviper.config">pyviper.config</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.config.set_regulators_filepath"><code class="docutils literal notranslate"><span class="pre">set_regulators_filepath()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.config.set_regulators_species_to_use"><code class="docutils literal notranslate"><span class="pre">set_regulators_species_to_use()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#id0"><code class="docutils literal notranslate"><span class="pre">set_regulators_filepath()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1"><code class="docutils literal notranslate"><span class="pre">set_regulators_species_to_use()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyviper.Interactome">pyviper.Interactome</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyviper.load">pyviper.load</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.load.TFs"><code class="docutils literal notranslate"><span class="pre">TFs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.load.coTFs"><code class="docutils literal notranslate"><span class="pre">coTFs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.load.human2mouse"><code class="docutils literal notranslate"><span class="pre">human2mouse()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.load.msigdb_regulon"><code class="docutils literal notranslate"><span class="pre">msigdb_regulon()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyviper.pl">pyviper.pl</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.__get_stored_uns_data_and_prep_to_plot"><code class="docutils literal notranslate"><span class="pre">__get_stored_uns_data_and_prep_to_plot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.pca"><code class="docutils literal notranslate"><span class="pre">pca()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.umap"><code class="docutils literal notranslate"><span class="pre">umap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.tsne"><code class="docutils literal notranslate"><span class="pre">tsne()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.diffmap"><code class="docutils literal notranslate"><span class="pre">diffmap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.draw_graph"><code class="docutils literal notranslate"><span class="pre">draw_graph()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.spatial"><code class="docutils literal notranslate"><span class="pre">spatial()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.embedding"><code class="docutils literal notranslate"><span class="pre">embedding()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.embedding_density"><code class="docutils literal notranslate"><span class="pre">embedding_density()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.heatmap"><code class="docutils literal notranslate"><span class="pre">heatmap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.dotplot"><code class="docutils literal notranslate"><span class="pre">dotplot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.tracksplot"><code class="docutils literal notranslate"><span class="pre">tracksplot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.violin"><code class="docutils literal notranslate"><span class="pre">violin()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.stacked_violin"><code class="docutils literal notranslate"><span class="pre">stacked_violin()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.matrixplot"><code class="docutils literal notranslate"><span class="pre">matrixplot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.clustermap"><code class="docutils literal notranslate"><span class="pre">clustermap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.ranking"><code class="docutils literal notranslate"><span class="pre">ranking()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pl.dendrogram"><code class="docutils literal notranslate"><span class="pre">dendrogram()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyviper.pp">pyviper.pp</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pp.rank_norm"><code class="docutils literal notranslate"><span class="pre">rank_norm()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pp.stouffer"><code class="docutils literal notranslate"><span class="pre">stouffer()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pp.mwu"><code class="docutils literal notranslate"><span class="pre">mwu()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pp.spearman"><code class="docutils literal notranslate"><span class="pre">spearman()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pp.viper_similarity"><code class="docutils literal notranslate"><span class="pre">viper_similarity()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pp.aracne3_to_regulon"><code class="docutils literal notranslate"><span class="pre">aracne3_to_regulon()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pp.nes_to_pval"><code class="docutils literal notranslate"><span class="pre">nes_to_pval()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pp.repr_subsample"><code class="docutils literal notranslate"><span class="pre">repr_subsample()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.pp.repr_metacells"><code class="docutils literal notranslate"><span class="pre">repr_metacells()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyviper.tl">pyviper.tl</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.tl.pca"><code class="docutils literal notranslate"><span class="pre">pca()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.tl.dendrogram"><code class="docutils literal notranslate"><span class="pre">dendrogram()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.tl.oncomatch"><code class="docutils literal notranslate"><span class="pre">oncomatch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.tl.find_top_mrs"><code class="docutils literal notranslate"><span class="pre">find_top_mrs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyviper.tl.path_enr"><code class="docutils literal notranslate"><span class="pre">path_enr()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pyviper-viper">pyviper.viper</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Tutorial-1.html">Tutorial 1 - Analyzing scRNA-seq data at the Protein Activity Level</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tutorial-2.html">Tutorial 2 - Inferring Protein Activity from scRNA-seq data from multiple cell populations with the meta-VIPER approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tutorial-3.html">Tutorial 3 - Generating metacells for reverse-engineering of ARACNe gene regulatory networks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pyviper</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">pyviper package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/pyviper.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pyviper-package">
<h1>pyviper package<a class="headerlink" href="#pyviper-package" title="Link to this heading"></a></h1>
<section id="pyviper-area">
<h2>pyviper.aREA<a class="headerlink" href="#pyviper-area" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyviper.</span></span><span class="sig-name descname"><span class="pre">aREA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gex_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interactome</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eset_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mvws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Allows the individual to infer normalized enrichment scores from gene
expression data using the Analytical Ranked Enrichment Analysis (aREA)[1]
function.</p>
<p>It is the original basis of the VIPER (Virtual Inference of Protein-activity
by Enriched Regulon analysis) algorithm.</p>
<p>The Interactome object must not contain any targets that are not in the
features of gex_data. This can be accomplished by running:</p>
<blockquote>
<div><p>interactome.filter_targets(gex_data.var_names)</p>
</div></blockquote>
<p>It is highly recommended to do this on the unPruned network and then prune
to ensure the pruned network contains a consistent number of targets per
regulator, all of which exist within gex_data. A consistent number of
targets allows regulators to have NES scores that are comparable to one
another. A regulator that has more targets than others will have “boosted”
NES scores, such that they cannot be compared to those with fewer targets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gex_data</strong> – Gene expression stored in an anndata object (e.g. from Scanpy) or in a
pd.DataFrame.</p></li>
<li><p><strong>interactome</strong> – An object of class Interactome.</p></li>
<li><p><strong>layer</strong> (<em>default: None</em>) – The layer in the anndata object to use as the gene expression input.</p></li>
<li><p><strong>eset_filter</strong> (<em>default: False</em>) – Whether to filter out genes not present in the interactome (True) or to
keep this biological context (False). This will affect gene rankings.</p></li>
<li><p><strong>min_targets</strong> (<em>default: 30</em>) – The minimum number of targets that each regulator in the interactome
should contain. Regulators that contain fewer targets than this minimum
will be culled from the network (via the Interactome.cull method). The
reason users may choose to use this threshold is because adequate
targets are needed to accurately predict enrichment.</p></li>
<li><p><strong>mvws</strong> (<em>default: 1</em>) – (A) Number indicating either the exponent score for the metaViper weights.
These are only applicable when enrichment = ‘area’ and are not used when
enrichment = ‘narnea’. Roughly, a lower number (e.g. 1) results in
networks being treated as a consensus network (useful for multiple
networks of the same celltype with the same epigenetics), while a higher
number (e.g. 10) results in networks being treated as separate (useful
for multiple networks of different celltypes with different epigenetics).
(B) The name of a column in gex_data that contains the manual assignments
of samples to networks using list position or network names.
(C) “auto”: assign samples to networks based on how well each
network allows for sample enrichment.</p></li>
<li><p><strong>verbose</strong> (<em>default: True</em>) – Whether extended output about the progress of the algorithm should be
given.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A dataframe of <code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code> containing NES values.</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Alvarez, M. J., Shen, Y., Giorgi, F. M., Lachmann, A., Ding, B. B., Ye, B. H., &amp; Califano, A. (2016). Functional characterization of somatic mutations in cancer using network-based inference of protein activity. Nature genetics, 48(8), 838-847.</p>
</dd></dl>

</section>
<section id="pyviper-narnea">
<h2>pyviper.NaRnEA<a class="headerlink" href="#pyviper-narnea" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyviper.</span></span><span class="sig-name descname"><span class="pre">NaRnEA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gex_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interactome</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eset_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Allows the individual to infer normalized enrichment scores and proportional
enrichment scores from gene expression data using the Nonparametric
Analytical Rank-based Enrichment Analysis (NaRnEA)[1] function.</p>
<p>NaRnEA is an updated basis for the VIPER (Virtual Inference of
Protein-activity by Enriched Regulon analysis) algorithm.</p>
<p>The Interactome object must not contain any targets that are not in the
features of gex_data. This can be accomplished by running:</p>
<blockquote>
<div><p>interactome.filter_targets(gex_data.var_names)</p>
</div></blockquote>
<p>It is highly recommend to do this on the unPruned network and then prune to
ensure the pruned network contains a consistent number of targets per
regulator, all of which exist within gex_data. A regulator that has more
targets than others will have “boosted” NES scores, such that they cannot be
compared to those with fewer targets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gex_data</strong> – Gene expression stored in an anndata object (e.g. from Scanpy) or in a
pd.DataFrame.</p></li>
<li><p><strong>interactome</strong> – An object of class Interactome.</p></li>
<li><p><strong>layer</strong> (<em>default: None</em>) – The layer in the anndata object to use as the gene expression input.</p></li>
<li><p><strong>eset_filter</strong> (<em>default: False</em>) – Whether to filter out genes not present in the interactome (True) or to
keep this biological context (False). This will affect gene rankings.</p></li>
<li><p><strong>min_targets</strong> (<em>default: 30</em>) – The minimum number of targets that each regulator in the interactome
should contain. Regulators that contain fewer targets than this minimum
will be culled from the network (via the Interactome.cull method). The
reason users may choose to use this threshold is because adequate
targets are needed to accurately predict enrichment.</p></li>
<li><p><strong>verbose</strong> (<em>default: True</em>) – Whether extended output about the progress of the algorithm should be
given.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>A dictionary containing :class:`~numpy.ndarray` containing NES values (key</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>‘nes’) and PES values (key: ‘pes’).</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Griffin, A. T., Vlahos, L. J., Chiuzan, C., &amp; Califano, A. (2023). NaRnEA: An Information Theoretic Framework for Gene Set Analysis. Entropy, 25(3), 542.</p>
</dd></dl>

</section>
<section id="module-pyviper.config">
<span id="pyviper-config"></span><h2>pyviper.config<a class="headerlink" href="#module-pyviper.config" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyviper.config.set_regulators_filepath">
<span class="sig-prename descclassname"><span class="pre">pyviper.config.</span></span><span class="sig-name descname"><span class="pre">set_regulators_filepath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">species</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_filepath</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.config.set_regulators_filepath" title="Link to this definition"></a></dt>
<dd><p>Allows the user to use a custom list of regulatory proteins instead of the
default ones within pyVIPER’s data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> – A group of regulatory proteins of either: “tfs”, “cotfs”, “sig” or “surf”.</p></li>
<li><p><strong>species</strong> – The species to which the group of proteins belongs to: “human” or “mouse”.</p></li>
<li><p><strong>new_filepath</strong> – The new filepath that should be used to retrieve these sets of proteins.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.config.set_regulators_species_to_use">
<span class="sig-prename descclassname"><span class="pre">pyviper.config.</span></span><span class="sig-name descname"><span class="pre">set_regulators_species_to_use</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">species</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.config.set_regulators_species_to_use" title="Link to this definition"></a></dt>
<dd><p>Allows the user to specify which species they are currently studying, so the
correct sets of regulatory proteins will be used during analysis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>species</strong> – The species to which the group of proteins belongs to: “human” or “mouse”.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id0">
<span class="sig-prename descclassname"><span class="pre">pyviper.config.</span></span><span class="sig-name descname"><span class="pre">set_regulators_filepath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">species</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_filepath</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id0" title="Link to this definition"></a></dt>
<dd><p>Allows the user to use a custom list of regulatory proteins instead of the
default ones within pyVIPER’s data folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> – A group of regulatory proteins of either: “tfs”, “cotfs”, “sig” or “surf”.</p></li>
<li><p><strong>species</strong> – The species to which the group of proteins belongs to: “human” or “mouse”.</p></li>
<li><p><strong>new_filepath</strong> – The new filepath that should be used to retrieve these sets of proteins.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id1">
<span class="sig-prename descclassname"><span class="pre">pyviper.config.</span></span><span class="sig-name descname"><span class="pre">set_regulators_species_to_use</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">species</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id1" title="Link to this definition"></a></dt>
<dd><p>Allows the user to specify which species they are currently studying, so the
correct sets of regulatory proteins will be used during analysis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>species</strong> – The species to which the group of proteins belongs to: “human” or “mouse”.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyviper.Interactome">
<span id="pyviper-interactome"></span><h2>pyviper.Interactome<a class="headerlink" href="#module-pyviper.Interactome" title="Link to this heading"></a></h2>
<p>Create an Interactome object to contain the results of ARACNe.
This object describes the relationship between regulator proteins (e.g.
TFs and CoTFs) and their downstream target genes with mor (Mode Of
Regulation, e.g. spearman correlation) indicating directionality and
likelihood (e.g. mutual information) indicating weight of association.
An Interactome object can be given to pyviper.viper along with a gene
expression signature to generate a protein activity matrix with the
VIPER (Virtual Inference of Protein-activity by Enriched Regulon
analysis) algorithm[1].</p>
<dl class="field-list">
<dt class="field-odd">param name<span class="colon">:</span></dt>
<dd class="field-odd"><p>A filepath to one’s disk to store the Interactome.</p>
</dd>
<dt class="field-even">param net_table<span class="colon">:</span></dt>
<dd class="field-even"><p>Either
(1) a pd.DataFrame containing four columns in this order:</p>
<blockquote>
<div><p>“regulator”, “target”, “mor”, “likelihood”</p>
</div></blockquote>
<p>(2) a filepath to this pd.DataFrame stored either as a .csv,
.tsv or .pkl.
(3) a filepath to an Interacome object stored as a .pkl.</p>
</dd>
<dt class="field-odd">type net_table<span class="colon">:</span></dt>
<dd class="field-odd"><p>default: None</p>
</dd>
<dt class="field-even">param input_type<span class="colon">:</span></dt>
<dd class="field-even"><p>Only relevant when net_table is a filepath. If None, the input_type
will be inferred from the net_table. Otherwise, specify “csv”, “tsv”
or “pkl”.</p>
</dd>
<dt class="field-odd">type input_type<span class="colon">:</span></dt>
<dd class="field-odd"><p>default: None</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Alvarez, M. J., Shen, Y., Giorgi, F. M., Lachmann, A., Ding, B. B., Ye, B. H., &amp; Califano, A. (2016). Functional characterization of somatic
mutations in cancer using network-based inference of protein activity.
Nature genetics, 48(8), 838-847.</p>
</section>
<section id="module-pyviper.load">
<span id="pyviper-load"></span><h2>pyviper.load<a class="headerlink" href="#module-pyviper.load" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyviper.load.TFs">
<span class="sig-prename descclassname"><span class="pre">pyviper.load.</span></span><span class="sig-name descname"><span class="pre">TFs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">species</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_to_tfs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.load.TFs" title="Link to this definition"></a></dt>
<dd><p>Retrieves a list of transcription factors (TFs).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>species</strong> (<em>default: None</em>) – When left as None, the species setting in pyviper.config will be used.
Otherwise, manually specify “human” or “mouse”.</p></li>
<li><p><strong>path_to_tfs</strong> (<em>default: None</em>) – When left as None, the path to TFs setting in pyviper.config will be used.
Otherwise, manually specify a filepath to a .txt file containing TFs,
one on each line.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A list containing transcription factors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.load.coTFs">
<span class="sig-prename descclassname"><span class="pre">pyviper.load.</span></span><span class="sig-name descname"><span class="pre">coTFs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">species</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_to_cotfs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.load.coTFs" title="Link to this definition"></a></dt>
<dd><p>Retrieves a list of co-transcription factors (coTFs).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>species</strong> (<em>default: None</em>) – When left as None, the species setting in pyviper.config will be used.
Otherwise, manually specify “human” or “mouse”.</p></li>
<li><p><strong>path_to_cotfs</strong> (<em>default: None</em>) – When left as None, the path to coTFs setting in pyviper.config will be used.
Otherwise, manually specify a filepath to a .txt file containing coTFs,
one on each line.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A list containing co-transcription factors.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.load.human2mouse">
<span class="sig-prename descclassname"><span class="pre">pyviper.load.</span></span><span class="sig-name descname"><span class="pre">human2mouse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.load.human2mouse" title="Link to this definition"></a></dt>
<dd><p>Retrieves the human to mouse translation pd.DataFrame from pyVIPER’s data
folder. This dataframe contains six columns:
human_symbol, mouse_symbol, human_ensembl, mouse_ensembl, human_entrez, mouse_entrez</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A dataframe of <code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.load.msigdb_regulon">
<span class="sig-prename descclassname"><span class="pre">pyviper.load.</span></span><span class="sig-name descname"><span class="pre">msigdb_regulon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">collection</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.load.msigdb_regulon" title="Link to this definition"></a></dt>
<dd><p>Retrieves an object or a list of objects of class Interactome from pyviper’s
data folder containing a set of pathways from the Molecular Signatures
Database (MSigDB), downloaded from <a class="reference external" href="https://www.gsea-msigdb.org/gsea/msigdb">https://www.gsea-msigdb.org/gsea/msigdb</a>.
These collections can be from one of the following:</p>
<blockquote>
<div><p>‘h’ for Hallmark gene sets. Coherently expressed signatures derived by
aggregating many MSigDB gene sets to represent well-defined biological
states or processes.
‘c2’ for curated gene sets. From online pathway databases, publications
in PubMed, and knowledge of domain experts.
‘c5’ for ontology gene sets. Consists of genes annotated by the same
ontology term.
‘c6’ for oncogenic signature gene sets. Defined directly from microarray
gene expression data from cancer gene perturbations.
‘c7’ for immunologic signature gene sets. Represents cell states and
perturbations within the immune system.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>collection</strong> – A individual string or a list of strings containing the following:
[“h”, “c2”, “c5”, “c6”, “c7”]
corresponding to the collections above.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>An individual object or list of objects of class pyviper.interactome.Interactome.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyviper.pl">
<span id="pyviper-pl"></span><h2>pyviper.pl<a class="headerlink" href="#module-pyviper.pl" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.__get_stored_uns_data_and_prep_to_plot">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">__get_stored_uns_data_and_prep_to_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uns_data_slot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obsm_slot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uns_slot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.__get_stored_uns_data_and_prep_to_plot" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.pca">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">pca</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.pca" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.pca.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’] on adata.obsm[‘X_pca’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’] on adata.obsm[‘X_pca’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.pca function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.umap">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">umap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.umap" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.umap.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’] on adata.obsm[‘X_umap’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’] on adata.obsm[‘X_umap’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.umap function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.tsne">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">tsne</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.tsne" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.tsne.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’] on adata.obsm[‘X_tsne’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’] on adata.obsm[‘X_tsne’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.tsne function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.diffmap">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">diffmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.diffmap" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.diffmap.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’] on adata.obsm[‘X_diffmap’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’] on adata.obsm[‘X_diffmap’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.diffmap function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.draw_graph">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">draw_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.draw_graph" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.draw_graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’] on adata.obsm[‘X_draw_graph_fa’] or adata.obsm[‘X_draw_graph_fr’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’] on adata.obsm[‘X_draw_graph_fa’] or adata.obsm[‘X_draw_graph_fr’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.draw_graph function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.spatial">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">spatial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.spatial" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.spatial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’] on adata.uns[‘spatial’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’] on adata.uns[‘spatial’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.spatial function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.embedding">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.embedding" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.embedding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>basis</strong> – The name of the represenation in adata.obsm that should be used for plotting.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’] on adata.obsm[basis].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’] on adata.obsm[basis].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.embedding function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.embedding_density">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">embedding_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'umap'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.embedding_density" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.embedding_density.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>basis</strong> (<em>default: 'umap'</em>) – The name of the represenation in adata.obsm that should be used for plotting.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’] on adata.obsm[basis].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’] on adata.obsm[basis].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.embedding_density function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.heatmap">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">heatmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.heatmap" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.heatmap.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.heatmap function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.dotplot">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">dotplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.dotplot" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.dotplot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.dotplot function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.tracksplot">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">tracksplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.tracksplot" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.tracksplot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.tracksplot function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.violin">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">violin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.violin" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.violin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.violin function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.stacked_violin">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">stacked_violin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.stacked_violin" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.stacked_violin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.stacked_violin function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.matrixplot">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">matrixplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.matrixplot" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.matrixplot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.matrixplot function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.clustermap">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">clustermap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.clustermap" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.clustermap.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.clustermap function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.ranking">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">ranking</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.ranking" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.ranking.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.ranking function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pl.dendrogram">
<span class="sig-prename descclassname"><span class="pre">pyviper.pl.</span></span><span class="sig-name descname"><span class="pre">dendrogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_gex_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_stored_pax_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pl.dendrogram" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.pl.dendrogram.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>plot_stored_gex_data</strong> (<em>default: False</em>) – Plot adata.uns[‘gex_data’].</p></li>
<li><p><strong>plot_stored_pax_data</strong> (<em>default: False</em>) – Plot adata.uns[‘pax_data’].</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.pl.dendrogram function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A plot of <code class="xref py py-class docutils literal notranslate"><span class="pre">Axes</span></code>.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyviper.pp">
<span id="pyviper-pp"></span><h2>pyviper.pp<a class="headerlink" href="#module-pyviper.pp" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pp.rank_norm">
<span class="sig-prename descclassname"><span class="pre">pyviper.pp.</span></span><span class="sig-name descname"><span class="pre">rank_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NUM_FUN=&lt;function</span> <span class="pre">_median&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DEM_FUN=&lt;function</span> <span class="pre">_mad_from_R&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_added=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pp.rank_norm" title="Link to this definition"></a></dt>
<dd><p>Compute a double rank normalization on an anndata, np.array, or pd.DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Data stored in an anndata object, np.array or pd.DataFrame.</p></li>
<li><p><strong>NUM_FUN</strong> (<em>default: np.median</em>) – The first function to be applied across each column.</p></li>
<li><p><strong>DEM_FUN</strong> (<em>default: _mad_from_R</em>) – The second function to be applied across each column.</p></li>
<li><p><strong>layer</strong> (<em>default: None</em>) – For an anndata input, the layer to use. When None, the input layer is
anndata.X.</p></li>
<li><p><strong>key_added</strong> (<em>default: None</em>) – For an anndata input, the name of the layer where to store. When None,
this is anndata.X.</p></li>
<li><p><strong>copy</strong> (<em>default: False</em>) – Whether to return a rank-transformed copy (True) or to instead transform
the original input (False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>When copy = False, saves the input data as a double rank transformed version.</em></p></li>
<li><p><em>When copy = True, return a double rank transformed version of the input data.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pp.stouffer">
<span class="sig-prename descclassname"><span class="pre">pyviper.pp.</span></span><span class="sig-name descname"><span class="pre">stouffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obs_column_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_by_feature_groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_added</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'stouffer'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_pvals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">null_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_as_df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pp.stouffer" title="Link to this definition"></a></dt>
<dd><p>Compute a stouffer signature on each of your clusters in an anndata object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata
object, or a pandas dataframe containing input data.</p></li>
<li><p><strong>obs_column_name</strong> – The name of the column of observations in adata to use as clusters, or a
cluster vector corresponding to observations.</p></li>
<li><p><strong>layer</strong> (<em>default: None</em>) – The layer to use as input data to compute the signatures.</p></li>
<li><p><strong>filter_by_feature_groups</strong> (<em>default: None</em>) – The selected regulators, such that all other regulators are filtered out
from input data. If None, all regulators will be included. Regulator
sets must be from one of the following: “tfs”, “cotfs”, “sig”, “surf”.</p></li>
<li><p><strong>key_added</strong> (<em>default: 'stouffer'</em>) – The slot in adata.uns to store the stouffer signatures.</p></li>
<li><p><strong>compute_pvals</strong> (<em>default: True</em>) – Whether to compute a p-value for each score to return in the results.</p></li>
<li><p><strong>null_iters</strong> (<em>default: 1000</em>) – The number of iterations to use to compute a null model to assess the
p-values of each of the stouffer scores.</p></li>
<li><p><strong>verbose</strong> (<em>default: True</em>) – Whether to provide additional output during the execution of the function.</p></li>
<li><p><strong>return_as_df</strong> (<em>default: False</em>) – If True, returns the stouffer signature in a pd.DataFrame. If False,
stores it in adata.var[key_added].</p></li>
<li><p><strong>copy</strong> (<em>default: False</em>) – Determines whether a copy of the input AnnData is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>When return_as_df is False, adds the cluster stouffer signatures to adata.var[key_added]. When return_as_df is True, returns as pd.DataFrame.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pp.mwu">
<span class="sig-prename descclassname"><span class="pre">pyviper.pp.</span></span><span class="sig-name descname"><span class="pre">mwu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obs_column_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_by_feature_groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_added</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mwu'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_pvals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_as_df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pp.mwu" title="Link to this definition"></a></dt>
<dd><p>Compute a Mann-Whitney U-Test signature on each of your clusters in an
anndata object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata
object, or a pandas dataframe containing input data.</p></li>
<li><p><strong>obs_column_name</strong> – The name of the column of observations in adata to use as clusters, or a
cluster vector corresponding to observations.</p></li>
<li><p><strong>layer</strong> (<em>default: None</em>) – The layer to use as input data to compute the signatures.</p></li>
<li><p><strong>filter_by_feature_groups</strong> (<em>default: None</em>) – The selected regulators, such that all other regulators are filtered out
from input data. If None, all regulators will be included. Regulator
sets must be from one of the following: “tfs”, “cotfs”, “sig”, “surf”.</p></li>
<li><p><strong>key_added</strong> (<em>default: 'mwu'</em>) – The slot in adata.uns to store the MWU signatures.</p></li>
<li><p><strong>compute_pvals</strong> (<em>default: True</em>) – Whether to compute a p-value for each score to return in the results.</p></li>
<li><p><strong>verbose</strong> (<em>default: True</em>) – Whether to provide additional output during the execution of the function.</p></li>
<li><p><strong>return_as_df</strong> (<em>default: False</em>) – If True, returns the MWU signature in a pd.DataFrame. If False,
stores it in adata.var[key_added].</p></li>
<li><p><strong>copy</strong> (<em>default: False</em>) – Determines whether a copy of the input AnnData is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>When return_as_df is False, adds the cluster MWU signatures to adata.var[key_added]. When return_as_df is True, returns as pd.DataFrame.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pp.spearman">
<span class="sig-prename descclassname"><span class="pre">pyviper.pp.</span></span><span class="sig-name descname"><span class="pre">spearman</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pca_slot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'X_pca'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obs_column_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_by_feature_groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_added</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'stouffer'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_pvals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">null_iters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_as_df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pp.spearman" title="Link to this definition"></a></dt>
<dd><p>Compute spearman correlation between each gene product and the cluster
centroids along with the statistical significance for each of your clusters
in an anndata object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata
object, or a pandas dataframe containing input data.</p></li>
<li><p><strong>pca_slot</strong> – The slot in adata.obsm where a PCA is stored.</p></li>
<li><p><strong>obs_column_name</strong> – The name of the column of observations in adata to use as clusters, or a
cluster vector corresponding to observations.</p></li>
<li><p><strong>layer</strong> (<em>default: None</em>) – The layer to use as input data to compute the correlation.</p></li>
<li><p><strong>filter_by_feature_groups</strong> (<em>default: None</em>) – The selected regulators, such that all other regulators are filtered out
from input data. If None, all regulators will be included. Regulator
sets must be from one of the following: “tfs”, “cotfs”, “sig”, “surf”.</p></li>
<li><p><strong>key_added</strong> (<em>default: 'spearman'</em>) – The slot in adata.uns to store the spearman correlation.</p></li>
<li><p><strong>compute_pvals</strong> (<em>default: True</em>) – Whether to compute a p-value for each score to return in the results.</p></li>
<li><p><strong>null_iters</strong> (<em>default: 1000</em>) – The number of iterations to use to compute a null model to assess the
p-values of each of the spearman scores.</p></li>
<li><p><strong>verbose</strong> (<em>default: True</em>) – Whether to provide additional output during the execution of the function.</p></li>
<li><p><strong>return_as_df</strong> (<em>default: False</em>) – If True, returns the spearman signature in a pd.DataFrame. If False,
stores it in adata.var[key_added].</p></li>
<li><p><strong>copy</strong> (<em>default: False</em>) – Determines whether a copy of the input AnnData is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>When return_as_df is False, adds the cluster spearman correlation to adata.var[key_added]. When return_as_df is True, returns as pd.DataFrame.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pp.viper_similarity">
<span class="sig-prename descclassname"><span class="pre">pyviper.pp.</span></span><span class="sig-name descname"><span class="pre">viper_similarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[4,</span> <span class="pre">2]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alternative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['two-sided',</span> <span class="pre">'greater',</span> <span class="pre">'less']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_by_feature_groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_added</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'viper_similarity'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pp.viper_similarity" title="Link to this definition"></a></dt>
<dd><p>Compute the similarity between the columns of a VIPER-predicted activity or
gene expression matrix. While following the same concept as the two-tail
Gene Set Enrichment Analysis (GSEA)[1], it is based on the aREA algorithm[2].</p>
<p>If ws is a single number, weighting is performed using an exponential function.
If ws is a 2 numbers vector, weighting is performed with a symmetric sigmoid
function using the first element as inflection point and the second as trend.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – An anndata.AnnData containing protein activity (NES), where rows are
observations/samples (e.g. cells or groups) and columns are features
(e.g. proteins or pathways).</p></li>
<li><p><strong>nn</strong> (<em>default: None</em>) – Optional number of top regulators to consider for computing the similarity</p></li>
<li><p><strong>ws</strong> (<em>default:</em><em> [</em><em>4</em><em>, </em><em>2</em><em>]</em>) – Number indicating the weighting exponent for the signature, or vector of
2 numbers indicating the inflection point and the value corresponding to
a weighting score of .1 for a sigmoid transformation, only used if nn is
ommited.</p></li>
<li><p><strong>alternative</strong> (<em>default: 'two-sided'</em>) – Character string indicating whether the most active (greater), less
active (less) or both tails (two.sided) of the signature should be used
for computing the similarity.</p></li>
<li><p><strong>layer</strong> (<em>default: None</em>) – The layer to use as input data to compute the signatures.</p></li>
<li><p><strong>filter_by_feature_groups</strong> (<em>default: None</em>) – The selected regulators, such that all other regulators are filtered out
from the input data. If None, all regulators will be included. Regulator
sets must be from one of the following: “tfs”, “cotfs”, “sig”, “surf”.</p></li>
<li><p><strong>key_added</strong> (<em>default: &quot;viper_similarity&quot;</em>) – The name of the slot in the adata.obsp to store the output.</p></li>
<li><p><strong>copy</strong> (<em>default: False</em>) – Determines whether a copy of the input AnnData is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Saves a signature-based distance numpy.ndarray in adata.obsp[key_added].</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Julio, M. K. -d. et al. Regulation of extra-embryonic endoderm stem cell differentiation by Nodal and Cripto signaling. Development 138, 3885-3895 (2011).</p>
<p>[2] Alvarez, M. J., Shen, Y., Giorgi, F. M., Lachmann, A., Ding, B. B., Ye, B. H., &amp; Califano, A. (2016). Functional characterization of somatic mutations in cancer using network-based inference of protein activity. Nature genetics, 48(8), 838-847.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pp.aracne3_to_regulon">
<span class="sig-prename descclassname"><span class="pre">pyviper.pp.</span></span><span class="sig-name descname"><span class="pre">aracne3_to_regulon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net_df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MI_thres</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regul_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_MI_per_regulon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pp.aracne3_to_regulon" title="Link to this definition"></a></dt>
<dd><p>Process an output from ARACNe3 to return a pd.DataFrame describing a gene
regulatory network with suitable columns for conversion to an object of the
Interactome class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net_file</strong> – A string containing the path to the ARACNe3 output</p></li>
<li><p><strong>net_df</strong> (<em>default: None</em>) – Whether to passt a pd.DataFrame instead of the path</p></li>
<li><p><strong>anno</strong> (<em>default: None</em>) – Gene ID annotation</p></li>
<li><p><strong>MI_thres</strong> (<em>default: 0</em>) – Threshold on Mutual Information (MI) to select the regulators and target pairs</p></li>
<li><p><strong>regul_size</strong> (<em>default: 50</em>) – Number of (top) targets to include in each regulon</p></li>
<li><p><strong>normalize_MI_per_regulon</strong> (<em>default: True</em>) – Whether to normalize MI values each regulon by the maximum value</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>A pd.DataFrame containing an ARACNe3-inferred gene regulatory network with the following 4 columns</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>“regulator”, “target”, “mor” (mode of regulation) and “likelihood”.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pp.nes_to_pval">
<span class="sig-prename descclassname"><span class="pre">pyviper.pp.</span></span><span class="sig-name descname"><span class="pre">nes_to_pval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_added</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjust</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg_log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pp.nes_to_pval" title="Link to this definition"></a></dt>
<dd><p>Transform VIPER-computed NES into p-values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata
object, or a pandas dataframe containing input data, where rows are
observations/samples (e.g. cells or groups) and columns are features
(e.g. proteins or pathways).</p></li>
<li><p><strong>layer</strong> (<em>default: None</em>) – Entry of layers to tranform.</p></li>
<li><p><strong>key_added</strong> (<em>default: None</em>) – Name of layer to save result in a new layer instead of adata.X.</p></li>
<li><p><strong>lower_tail</strong> (<em>default: True</em>) – If <cite>True</cite> (default), probabilities are P(X &lt;= x)
If <cite>False</cite>, probabilities are P(X &gt; x)</p></li>
<li><p><strong>adjust</strong> (<em>default: True</em>) – If <cite>True</cite>, returns adjusted p values using FDR Benjamini-Hochberg procedure.
If <cite>False</cite>, does not adjust p values</p></li>
<li><p><strong>axs</strong> (<em>default: 1</em>) – axis along which to perform the p-value correction (Used only if the input is a pd.DataFrame).
Possible values are 0 or 1.</p></li>
<li><p><strong>neg_log</strong> (<em>default: False</em>) – Whether to transform VIPER-computed NES into -log10(p-value).</p></li>
<li><p><strong>copy</strong> (<em>default: False</em>) – Determines whether a copy of the input AnnData is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Saves the input data as a transformed version. If key_added is specified, saves the results in adata.layers[key_added].</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pp.repr_subsample">
<span class="sig-prename descclassname"><span class="pre">pyviper.pp.</span></span><span class="sig-name descname"><span class="pre">repr_subsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pca_slot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'X_pca'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_added</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'repr_subsample'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eliminate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">njobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pp.repr_subsample" title="Link to this definition"></a></dt>
<dd><p>A tool for create a subsample of the input data such it is well
representative of all the populations within the input data rather than
being a random sample. This is accomplished by pairing samples together in
an iterative fashion until the desired sample size is reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – An anndata object containing a distance object in adata.obsp.</p></li>
<li><p><strong>pca_slot</strong> (<em>default: &quot;X_pca&quot;</em>) – The slot in adata.obsm where the PCA object is stored. One way of
generating this object is with sc.pp.pca.</p></li>
<li><p><strong>size</strong> (<em>default: 1000</em>) – The size of the representative subsample</p></li>
<li><p><strong>eliminate</strong> (<em>default: False</em>) – Whether to trim down adata to the subsample (True) or leave the
subsample as an annotation in adata.obs[key_added].</p></li>
<li><p><strong>seed</strong> (<em>default: 0</em>) – The random seed used when taking samples of the data.</p></li>
<li><p><strong>verbose</strong> (<em>default: True</em>) – Whether to provide runtime information.</p></li>
<li><p><strong>njobs</strong> (<em>default: 1</em>) – The number of cores to use for the analysis. Using more than 1 core
(multicore) speeds up the analysis.</p></li>
<li><p><strong>copy</strong> (<em>default: False</em>) – Determines whether a copy of the input AnnData is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>When copy is False, saves the subsample annotation in adata.var[key_added].</em></p></li>
<li><p><em>When copy is True, return an anndata with this annotation.</em></p></li>
<li><p><em>When eliminate is True, modify the adata by subsetting it down to the subsample.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.pp.repr_metacells">
<span class="sig-prename descclassname"><span class="pre">pyviper.pp.</span></span><span class="sig-name descname"><span class="pre">repr_metacells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pca_slot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'X_pca'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist_slot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'corr_dist'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusters_slot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score_slot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score_min_thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_cells_per_metacell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_median_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perc_data_to_use</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perc_incl_data_reused</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_added</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'metacells'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">njobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.pp.repr_metacells" title="Link to this definition"></a></dt>
<dd><p>A tool for create a representative selection of metacells from the data that
aims to maximize reusing samples from the data, while simultaneously
ensuring that all neighbors are close to the metacell they construct.
When using this function, exactly two of the following parameters must be
set: size, min_median_depth or n_cells_per_metacell, perc_data_to_use or
perc_incl_data_reused.
Note that min_median_depth and n_cells_per_metacell cannot both be set
at the same time, since they directly relate (e.g. higher n_cells_per_metacell
means more neighbors are used to construct a single metacell, meaning each
metacell will have more counts, resulting in a higher median depth).
Note that perc_data_to_use and perc_incl_data_reused cannot both be set
at the same time, since they directly relate (e.g. higher perc_data_to_use
means you include more data, which means it’s more likely to reuse more
data, resulting in a higher perc_incl_data_reused).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – An anndata object containing a distance object in adata.obsp.</p></li>
<li><p><strong>counts</strong> (<em>default: None</em>) – A pandas DataFrame or AnnData object of unnormalized gene expression
counts that has the same samples in the same order as that of adata.
If counts are left as None, adata must have counts stored in adata.raw.</p></li>
<li><p><strong>pca_slot</strong> (<em>default: &quot;X_pca&quot;</em>) – The slot in adata.obsm where the PCA object is stored. One way of
generating this object is with sc.pp.pca.</p></li>
<li><p><strong>dist_slot</strong> (<em>default: &quot;corr_dist&quot;</em>) – The slot in adata.obsp where the distance object is stored. One way of
generating this object is with pyviper.pp.corr_distance.</p></li>
<li><p><strong>clusters_slot</strong> (<em>default: None</em>) – The slot in adata.obs where cluster labels are stored. Cluster-specific
metacells will be generated using the same parameters with the results
for each cluster being stored separately in adata.uns.</p></li>
<li><p><strong>score_slot</strong> (<em>default: None</em>) – The slot in adata.obs where a score used to determine and filter cell
quality are stored (e.g. silhouette score).</p></li>
<li><p><strong>score_min_thresh</strong> (<em>default: None</em>) – The score from adata.obs[score_slot] that a cell must have at minimum to
be used for metacell construction (e.g. 0.25 is the rule of thumb for
silhouette score).</p></li>
<li><p><strong>size</strong> (<em>default: 500</em>) – A specific number of metacells to generate. If set to None,
perc_data_to_use or perc_incl_data_reused can be used to specify the size
when n_cells_per_metacell or min_median_depth is given.</p></li>
<li><p><strong>n_cells_per_metacell</strong> (<em>default: None</em>) – The number of cells that should be used to generate single metacell.
Note that this parameter and min_median_depth cannot both be set as
they directly relate: e.g. higher n_cells_per_metacell leads to higher
min_median_depth. If left as None, perc_data_to_use or
perc_incl_data_reused can be used to specify n_cells_per_metacell when
size is given.</p></li>
<li><p><strong>min_median_depth</strong> (<em>default: 10000</em>) – The desired minimum median depth for the metacells (indirectly specifies
n_cells_per_metacell). The default is set to 10000 as this is recommend
by PISCES[1]. Note that this parameter and n_cells_per_metacell cannot
both be set as they directly relate: e.g. higher min_median_depth leads
to higher n_cells_per_metacell.</p></li>
<li><p><strong>perc_data_to_use</strong> (<em>default: None</em>) – The percent of the total amount of provided samples that will be used in
the creation of metacells. Note that this parameter and
perc_incl_data_reused cannot both be set as they directly relate: e.g.
higher perc_data_to_use leads to higher perc_incl_data_reused.</p></li>
<li><p><strong>perc_incl_data_reused</strong> (<em>default: None</em>) – The percent of samples that are included in the creation of metacells
that will be reused (i.e. used in more than one metacell). Note that this
parameter and perc_data_to_use cannot both be set as they directly relate:
e.g. higher perc_incl_data_reused leads to higher perc_data_to_use.</p></li>
<li><p><strong>seed</strong> (<em>default: 0</em>) – The random seed used when taking samples of the data.</p></li>
<li><p><strong>key_added</strong> (<em>default: &quot;metacells&quot;</em>) – The name of the slot in the adata.uns to store the output.</p></li>
<li><p><strong>verbose</strong> (<em>default: True</em>) – Whether to provide runtime information and quality statistics.</p></li>
<li><p><strong>njobs</strong> (<em>default: 1</em>) – The number of cores to use for the analysis. Using more than 1 core
(multicore) speeds up the analysis.</p></li>
<li><p><strong>copy</strong> (<em>default: False</em>) – Determines whether a copy of the input AnnData is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Saves the metacells as a pandas dataframe in adata.uns[key_added]. Attributes that contain parameters for and statistics about the construction of the metacells are stored in adata.uns[key_added].attrs. Set copy = True to return a new AnnData object.</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>Obradovic, A., Vlahos, L., Laise, P., Worley, J., Tan, X., Wang, A., &amp; Califano, A. (2021). PISCES: A pipeline for the systematic, protein activity -based analysis of single cell RNA sequencing data. bioRxiv, 6, 22.</p>
</dd></dl>

</section>
<section id="module-pyviper.tl">
<span id="pyviper-tl"></span><h2>pyviper.tl<a class="headerlink" href="#module-pyviper.tl" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyviper.tl.pca">
<span class="sig-prename descclassname"><span class="pre">pyviper.tl.</span></span><span class="sig-name descname"><span class="pre">pca</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_by_feature_groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.tl.pca" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.tl.pca.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>layer</strong> (<em>default: None</em>) – The layer to use as input data.</p></li>
<li><p><strong>filter_by_feature_groups</strong> (<em>default: None</em>) – The selected regulators, such that all other regulators are filtered out
from the input data. If None, all regulators will be included. Regulator
sets must be from one of the following: “tfs”, “cotfs”, “sig”, “surf”.</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.tl.pca function.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.tl.dendrogram">
<span class="sig-prename descclassname"><span class="pre">pyviper.tl.</span></span><span class="sig-name descname"><span class="pre">dendrogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">groupby</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_added</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_by_feature_groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.tl.dendrogram" title="Link to this definition"></a></dt>
<dd><p>A wrapper for the scanpy function sc.tl.dendrogram.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – Gene expression, protein activity or pathways stored in an anndata object.</p></li>
<li><p><strong>key_added</strong> (<em>default: None</em>) – The key in adata.uns where the dendrogram should be stored.</p></li>
<li><p><strong>layer</strong> (<em>default: None</em>) – The layer to use as input data.</p></li>
<li><p><strong>filter_by_feature_groups</strong> (<em>default: None</em>) – The selected regulators, such that all other regulators are filtered out
from the input data. If None, all regulators will be included. Regulator
sets must be from one of the following: “tfs”, “cotfs”, “sig”, “surf”.</p></li>
<li><p><strong>**kwargs</strong> – Arguments to provide to the sc.tl.dendrogram function.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.tl.oncomatch">
<span class="sig-prename descclassname"><span class="pre">pyviper.tl.</span></span><span class="sig-name descname"><span class="pre">oncomatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pax_data_to_test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pax_data_for_cMRs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tcm_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">both_ways</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">om_max_NES_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">om_min_logp_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enrichment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'aREA'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_added</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'om'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_as_df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.tl.oncomatch" title="Link to this definition"></a></dt>
<dd><p>The OncoMatch algorithm[1] assesses the overlap in differentially active MR
proteins between two sets of samples (e.g. to validate GEMMs as effective
models of human tumor samples). It does so by computing -log10 p-values for
each sample in pax_data_to_test of the MRs of each sample in pax_data_for_cMRs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pax_data_to_test</strong> – An anndata.AnnData or pd.DataFrame containing protein activity (NES),
where rows are observations/samples (e.g. cells or groups) and
columns are features (e.g. proteins or pathways).</p></li>
<li><p><strong>pax_data_for_cMRs</strong> – An anndata.AnnData or pd.DataFrame containing protein activity (NES),
where rows are observations/samples (e.g. cells or groups) and
columns are features (e.g. proteins or pathways).</p></li>
<li><p><strong>tcm_size</strong> (<em>default: 50</em>) – Number of top MRs from each sample to use to compute regulators.</p></li>
<li><p><strong>both_ways</strong> (<em>default: False</em>) – Whether to also use the candidate MRs of pax_data_to_test to compute
NES for the samples in pax_data_for_cMRs, and then average.</p></li>
<li><p><strong>om_max_NES_threshold</strong> (<em>default: 30</em>) – The maximum NES scores before using a cutoff.</p></li>
<li><p><strong>om_min_logp_threshold</strong> (<em>default: 0</em>) – The minimum logp value threshold, such that all logp values smaller than
this value are set to 0.</p></li>
<li><p><strong>enrichment</strong> (<em>default: 'aREA'</em>) – The method of compute enrichment. ‘aREA’ or ‘NaRnEA’</p></li>
<li><p><strong>key_added</strong> (<em>default: 'om'</em>) – The slot in pax_data_to_test.obsm to store the oncomatch results.</p></li>
<li><p><strong>return_as_df</strong> (<em>default: False</em>) – Instead of adding the OncoMatch DataFrame to pax_data_to_test.obsm,
return it directly.</p></li>
<li><p><strong>copy</strong> (<em>default: False</em>) – Determines whether a copy of the input AnnData is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>When copy is False, stores a pd.DataFrame objects of -log10 p-values with shape (n_samples in pax_data_to_test, n_samples in pax_data_for_cMRs) in pax_data_to_test.obsm[key_added]. When copy is True, a copy of the AnnData is returned with these pd.DataFrames stored. When return_as_df is True, the OncoMatch DataFrame alone is directly returned by the function.</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Alvarez, M. J. et al. A precision oncology approach to the pharmacological targeting of mechanistic dependencies in neuroendocrine tumors. Nat Genet 50, 979–989, doi:10.1038/s41588-018-0138-4 (2018).</p>
<p>[2] Alvarez, M. J. et al. Reply to ’H-STS, L-STS and KRJ-I are not authentic GEPNET cell lines’. Nat Genet 51, 1427–1428, doi:10.1038/s41588-019-0509-5 (2019).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.tl.find_top_mrs">
<span class="sig-prename descclassname"><span class="pre">pyviper.tl.</span></span><span class="sig-name descname"><span class="pre">find_top_mrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pca_slot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'X_pca'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obs_column_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">both</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'stouffer'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_added</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mr'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_by_feature_groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_by_top_mrs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_as_df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.tl.find_top_mrs" title="Link to this definition"></a></dt>
<dd><p>Identify the top N master regulator proteins in a VIPER AnnData object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adata</strong> – An anndata object containing a distance object in adata.obsp.</p></li>
<li><p><strong>pca_slot</strong> – The slot in adata.obsm where a PCA is stored. Only required when method
is “spearman”.</p></li>
<li><p><strong>obs_column_name</strong> – The name of the column of observations in adata to use as clusters, or a
cluster vector corresponding to observations. Required when method is
“mwu” or “spearman”.</p></li>
<li><p><strong>N</strong> (<em>default: 50</em>) – The number of MRs to return</p></li>
<li><p><strong>both</strong> (<em>default: True</em>) – Whether to return both the top N and bottom N MRs (True) or just the
top N (False).</p></li>
<li><p><strong>method</strong> (<em>default: &quot;stouffer&quot;</em>) – The method used to compute a signature to identify the top candidate
master regulators (MRs). The options come from functions in pyviper.pp.
Choose between “stouffer”, “mwu”, or “spearman”.</p></li>
<li><p><strong>key_added</strong> (<em>default: &quot;mr&quot;</em>) – The name of the slot in the adata.var to store the output.</p></li>
<li><p><strong>filter_by_feature_groups</strong> (<em>default: None</em>) – The selected regulators, such that all other regulators are filtered out
from the input data. If None, all regulators will be included. Regulator
sets must be from one of the following: “tfs”, “cotfs”, “sig”, “surf”.</p></li>
<li><p><strong>rank</strong> (<em>default: False</em>) – When False, a column is added to var with identified MRs labeled as
“True”, while all other proteins are labeled as “False”. When True, top
MRs are labeled N,N-1,N-2,…,1, bottom MRs are labeled -N,-N-1,-N-2,
…,-1, and all other proteins are labeled 0. Higher rank means greater
activity, while lower rank means less.</p></li>
<li><p><strong>filter_by_top_mrs</strong> (<em>default: False</em>) – Whether to filter var to only the top MRs in adata</p></li>
<li><p><strong>return_as_df</strong> (<em>default: False</em>) – Returns a pd.DataFrame of the top MRs per cluster</p></li>
<li><p><strong>copy</strong> (<em>default: False</em>) – Determines whether a copy of the input AnnData is returned.</p></li>
<li><p><strong>verbose</strong> (<em>default: True</em>) – Whether extended output about the progress of the algorithm is given.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Add a column to adata.var[key_added] or, when clusters given, adds multiple columns (e.g. key_added_clust1name, key_added_clust2name, etc) to adata.var. If copy, returns a new adata transformed by this function. If return_as_df, returns a DataFrame.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyviper.tl.path_enr">
<span class="sig-prename descclassname"><span class="pre">pyviper.tl.</span></span><span class="sig-name descname"><span class="pre">path_enr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gex_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathway_interactome</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eset_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enrichment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'aREA'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mvws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">njobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_as_anndata</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transfer_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_input_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyviper.tl.path_enr" title="Link to this definition"></a></dt>
<dd><p>Run the variation of VIPER that is specific to pathway enrichment analysis:
a single interactome and min_targets is set to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gex_data</strong> – Gene expression stored in an anndata object (e.g. from Scanpy).</p></li>
<li><p><strong>pathway_interactome</strong> – An object of class Interactome or one of the following strings that
corresponds to msigdb regulons: “c2”, “c5”, “c6”, “c7”, “h”.</p></li>
<li><p><strong>layer</strong> (<em>default: None</em>) – The layer in the anndata object to use as the gene expression input.</p></li>
<li><p><strong>eset_filter</strong> (<em>default: False</em>) – Whether to filter out genes not present in the interactome (True) or to
keep this biological context (False). This will affect gene rankings.</p></li>
<li><p><strong>method</strong> (<em>default: None</em>) – A method used to create a gene expression signature from gex_data.X. The
default of None is used when gex_data.X is already a gene expression
signature. Alternative inputs include “scale”, “rank”, “doublerank”,
“mad”, and “ttest”.</p></li>
<li><p><strong>enrichment</strong> (<em>default: 'aREA'</em>) – The algorithm to use to calculate the enrichment. Choose betweeen
Analytical Ranked Enrichment Analysis (aREA) and Nonparametric
Analytical Rank-based Enrichment Analysis (NaRnEA) function. Default =’aREA’,
alternative = ‘NaRnEA’.</p></li>
<li><p><strong>mvws</strong> (<em>default: 1</em>) – (A) Number indicating either the exponent score for the metaViper weights.
These are only applicable when enrichment = ‘aREA’ and are not used when
enrichment = ‘NaRnEA’. Roughly, a lower number (e.g. 1) results in
networks being treated as a consensus network (useful for multiple
networks of the same celltype with the same epigenetics), while a higher
number (e.g. 10) results in networks being treated as separate (useful
for multiple networks of different celltypes with different epigenetics).
(B) The name of a column in gex_data that contains the manual assignments
of samples to networks using list position or network names.
(C) “auto”: assign samples to networks based on how well each
network allows for sample enrichment.</p></li>
<li><p><strong>njobs</strong> (<em>default: 1</em>) – Number of cores to distribute sample batches into.</p></li>
<li><p><strong>batch_size</strong> (<em>default: 10000</em>) – Maximum number of samples to process at once. Set to None to split all
samples across provided <cite>njobs</cite>.</p></li>
<li><p><strong>verbose</strong> (<em>default: True</em>) – Whether extended output about the progress of the algorithm is given.</p></li>
<li><p><strong>output_as_anndata</strong> (<em>default: True</em>) – Way of delivering output.</p></li>
<li><p><strong>transfer_obs</strong> (<em>default: True</em>) – Whether to transfer the observation metadata from the input anndata to
the output anndata. Thus, not applicable when output_as_anndata==False.</p></li>
<li><p><strong>store_input_data</strong> (<em>default: True</em>) – Whether to store the input anndata in an unstructured data slot (.uns) of
the output anndata. Thus, not applicable when output_as_anndata==False.
If input anndata already contains ‘gex_data’ in .uns, the input will
assumed to be protein activity and will be stored in .uns as ‘pax_data’.
Otherwise, the data will be stored as ‘gex_data’ in .uns.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns an AnnData object containing the pathways. When store_input_data, the input gex_data AnnData is stored within the dataframe.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="pyviper-viper">
<h2>pyviper.viper<a class="headerlink" href="#pyviper-viper" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">pyviper.</span></span><span class="sig-name descname"><span class="pre">viper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gex_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interactome</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eset_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enrichment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'aREA'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mvws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">njobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_as_anndata</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transfer_obs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_input_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>The VIPER (Virtual Inference of Protein-activity by Enriched Regulon
analysis) algorithm[1] allows individuals to compute protein activity
using a gene expression signature and an Interactome object that describes
the relationship between regulators and their downstream targets.
Users can infer normalized enrichment scores (NES) using Analytical Ranked
Enrichment Analysis (aREA)[1] or Nonparametric Analytical Rank-based
Enrichment Analysis (NaRnEA)[2]. NaRnEA also compute proportional enrichment
scores (PES).</p>
<p>The Interactome object must not contain any targets that are not in the
features of gex_data. This can be accomplished by running:</p>
<blockquote>
<div><p>interactome.filter_targets(gex_data.var_names)</p>
</div></blockquote>
<p>It is highly recommend to do this on the unPruned network and then prune to
ensure the pruned network contains a consistent number of targets per
regulator, allow of which exist within gex_data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gex_data</strong> – Gene expression stored in an anndata object (e.g. from Scanpy).</p></li>
<li><p><strong>interactome</strong> – An object of class Interactome or a list of Interactome objects.</p></li>
<li><p><strong>layer</strong> (<em>default: None</em>) – The layer in the anndata object to use as the gene expression input.</p></li>
<li><p><strong>eset_filter</strong> (<em>default: False</em>) – Whether to filter out genes not present in the interactome (True) or to
keep this biological context (False). This will affect gene rankings.</p></li>
<li><p><strong>method</strong> (<em>default: None</em>) – A method used to create a gene expression signature from gex_data.X. The
default of None is used when gex_data.X is already a gene expression
signature. Alternative inputs include “scale”, “rank”, “doublerank”,
“mad”, and “ttest”.</p></li>
<li><p><strong>enrichment</strong> (<em>default: 'aREA'</em>) – The algorithm to use to calculate the enrichment. Choose betweeen
Analytical Ranked Enrichment Analysis (aREA) and Nonparametric
Analytical Rank-based Enrichment Analysis (NaRnEA) function. Default =’aREA’,
alternative = ‘NaRnEA’.</p></li>
<li><p><strong>mvws</strong> (<em>default: 1</em>) – (A) Number indicating either the exponent score for the metaViper weights.
These are only applicable when enrichment = ‘aREA’ and are not used when
enrichment = ‘NaRnEA’. Roughly, a lower number (e.g. 1) results in
networks being treated as a consensus network (useful for multiple
networks of the same celltype with the same epigenetics), while a higher
number (e.g. 10) results in networks being treated as separate (useful
for multiple networks of different celltypes with different epigenetics).
(B) The name of a column in gex_data that contains the manual assignments
of samples to networks using list position or network names.
(C) “auto”: assign samples to networks based on how well each
network allows for sample enrichment.</p></li>
<li><p><strong>min_targets</strong> (<em>default: 30</em>) – The minimum number of targets that each regulator in the interactome
should contain. Regulators that contain fewer targets than this minimum
will be pruned from the network (via the Interactome.prune method). The
reason users may choose to use this threshold is because adequate
targets are needed to accurately predict enrichment.</p></li>
<li><p><strong>njobs</strong> (<em>default: 1</em>) – Number of cores to distribute sample batches into.</p></li>
<li><p><strong>batch_size</strong> (<em>default: 10000</em>) – Maximum number of samples to process at once. Set to None to split all
samples across provided <cite>njobs</cite>.</p></li>
<li><p><strong>verbose</strong> (<em>default: True</em>) – Whether extended output about the progress of the algorithm should be
given.</p></li>
<li><p><strong>output_as_anndata</strong> (<em>default: True</em>) – Way of delivering output.</p></li>
<li><p><strong>transfer_obs</strong> (<em>default: True</em>) – Whether to transfer the observation metadata from the input anndata to
the output anndata. Thus, not applicable when output_as_anndata==False.</p></li>
<li><p><strong>store_input_data</strong> (<em>default: True</em>) – Whether to store the input anndata in an unstructured data slot (.uns) of
the output anndata. Thus, not applicable when output_as_anndata==False.
If input anndata already contains ‘gex_data’ in .uns, the input will
assumed to be protein activity and will be stored in .uns as ‘pax_data’.
Otherwise, the data will be stored as ‘gex_data’ in .uns.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A dictionary containing :class:`~numpy.ndarray` containing NES values (key</strong> (<em>‘nes’) and PES values (key: ‘pes’) when output_as_anndata=False and enrichment = “NaRnEA”.</em>)</p></li>
<li><p>A dataframe of <code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code> containing NES values when output_as_anndata=False and enrichment = “aREA”.</p></li>
<li><p><em>An anndata object containin NES values in .X when output_as_anndata=True (default). Will contain PES values in the layer ‘pes’ when enrichment = ‘NaRnEA’. Will contain .gex_data and/or .pax_data in the unstructured data slot (.uns) when store_input_data = True. Will contain identical .obs to the input anndata when transfer_obs = True.</em></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Alvarez, M. J., Shen, Y., Giorgi, F. M., Lachmann, A., Ding, B. B., Ye, B. H., &amp; Califano, A. (2016). Functional characterization of somatic mutations in cancer using network-based inference of protein activity. Nature genetics, 48(8), 838-847.</p>
<p>[2] Griffin, A. T., Vlahos, L. J., Chiuzan, C., &amp; Califano, A. (2023). NaRnEA: An Information Theoretic Framework for Gene Set Analysis. Entropy, 25(3), 542.</p>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="pyVIPER (VIPER Analysis in Python for single-cell RNASeq)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Tutorial-1.html" class="btn btn-neutral float-right" title="Tutorial 1 - Analyzing scRNA-seq data at the Protein Activity Level" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>